// TODO make file path editable
// TODO make strings const

using UnityEngine;
using UnityEditor;
using System.IO;
using System.Text.RegularExpressions;

public class BitMaskGenerator : EditorWindow
{
    private const string class_src_path = "Assets/ScriptableVariables/Scripts/Editor/CodeGenerators/Templates/BitMaskVariableTemplate.txt";
    private const string editor_src_path = "Assets/ScriptableVariables/Scripts/Editor/CodeGenerators/Templates/BitMaskEditorTemplate.txt";
    private const string class_dest_path = "Assets/ScriptableVariables/Scripts/Classes/AutoGenerated/BitMasks/{0}BitMask.cs";
    private const string editor_dest_path = "Assets/ScriptableVariables/Scripts/Editor/AutoGenerated/BitMasks/{0}Editor.cs";

    private const string header =
@"
///////////////////////////////////////////////////////////////////
/////// Automatically generated by BitMaskGenerator.cs ////////////
///////////////////////////////////////////////////////////////////
";

    private static string nameStr = "";
    private static string valuesStr = "";
    private static int numValues = -1;
    private static string[] lastKnownValues;

    // TODO: Feature not quite ready :(
    //[MenuItem("Window/Scriptable Variables/Create new BitMask type")]
    public static void CreateNewBitMaskType()
    {
        BitMaskGenerator window = (BitMaskGenerator)GetWindow(typeof(BitMaskGenerator));
        window.Show();
    }

    private enum Places
    {
        _16 = 16, _32 = 32
    }

    private static Places places = Places._16;

    private void OnGUI()
    {
        GUILayout.Label("BitMask Type Generator", EditorStyles.boldLabel);
        GUILayout.Space(40f);
        nameStr = EditorGUILayout.TextField("BitMask Name: ", nameStr);
        GUILayout.Space(10f);
        places = (Places)EditorGUILayout.EnumPopup("Number of places: ", places);

        int tmp = (int)places;

        if(tmp != numValues)
        {
            if(lastKnownValues == null)
            {
                lastKnownValues = new string[tmp];
            }
            else
            {
                string[] tmpStr = new string[tmp];
                for(int i = 0; i < ((tmp < numValues) ? tmp : numValues); ++i) {
                    tmpStr[i] = lastKnownValues[i];
                }
                lastKnownValues = tmpStr;
            }
            numValues = tmp;
        }

        for (int i = 0; i < numValues; ++i)
        {
            lastKnownValues[i] = EditorGUILayout.TextField($"{i}", lastKnownValues[i] ?? "");
        }
        
        GUILayout.Space(10f);
        //defaultValue = EditorGUILayout.IntField("Default Value: ", defaultValue);
        //if(lastKnownValues != null)
        //{
        //    defaultValue = (defaultValue < lastKnownValues.Length) ? defaultValue : 0;
        //    GUILayout.Label($"({lastKnownValues[defaultValue]})");
        //}


        if (GUILayout.Button("Generate BitMask"))
        {
            if(!IsScriptNameValid(nameStr))
            {
                EditorUtility.DisplayDialog("Invalid Class Name", "Enum Variables should start with a letter and should only contain letters, numbers and underscores.", "Alrighty then");
                return;
            }

            valuesStr = "";

            for(int i = 0; i < lastKnownValues.Length; ++i)
            {
                // TODO validate values
                if(lastKnownValues[i].Length > 0 && !IsScriptNameValid(lastKnownValues[i]))
                {
                    EditorUtility.DisplayDialog($"Invalid Name: {lastKnownValues[i]}", "BitMask Values should start with a letter and should only contain letters, numbers and underscores.", "Alrighty then");
                    return;
                }

                valuesStr += (lastKnownValues[i].Length > 0) ? lastKnownValues[i] + $" = 1 << {i},\r\n            "
                    : $"Bit_{i} = 1 << {i},\r\n            ";
            }

            try
            {
                string scriptTemplate = File.ReadAllText(class_src_path);
                string editorTemplate = File.ReadAllText(editor_src_path);

                string scriptStr = string.Format(scriptTemplate, header, nameStr, numValues.ToString());
                string editorStr = string.Format(editorTemplate, header, nameStr, (places == Places._16) ? "ushort" : "uint", valuesStr);

                System.IO.FileInfo file = new FileInfo(string.Format(class_dest_path, nameStr));
                file.Directory.Create(); // If the directory already exists, this method does nothing.
                System.IO.File.WriteAllText(file.FullName, scriptStr);

                file = new FileInfo(string.Format(editor_dest_path, nameStr));
                file.Directory.Create();
                System.IO.File.WriteAllText(file.FullName, editorStr);

                EditorUtility.DisplayDialog("Success", "Created script and editor file", "Nicenstein");
                AssetDatabase.Refresh();
            }
            catch(System.Exception e)
            {
                EditorUtility.DisplayDialog("Error", e.Message, "Sad");
            }
        }
    }

    private static bool IsScriptNameValid(string name)
    {
        // should start with a letter and can only contain numbers, letters and underscores
        Regex validName = new Regex("^[a-zA-Z]+[0-9a-zA-Z_]*$");
        return validName.IsMatch(name);
    }

    private static bool IsEnumValueValid(string name)
    {
        Regex validName = new Regex("^[a-zA-Z]+[0-9a-zA-Z_]*$");
        return validName.IsMatch(name);
    }
}
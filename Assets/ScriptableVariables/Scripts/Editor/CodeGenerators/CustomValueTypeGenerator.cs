// TODO make file path editable
// TODO make strings const

using UnityEngine;
using UnityEditor;
using System.IO;
using System;
using System.Text.RegularExpressions;
using System.Linq;

public class CustomValueTypeGenerator : EditorWindow
{
    private const string class_src_path = "Assets/ScriptableVariables/Scripts/Editor/CodeGenerators/Templates/CustomValueTypeTemplate.txt";
    private const string listener_src_path = "Assets/ScriptableVariables/Scripts/Editor/CodeGenerators/Templates/CustomValueListenerTemplate.txt";
    private const string editor_src_path = "Assets/ScriptableVariables/Scripts/Editor/CodeGenerators/Templates/CustomValueEditorTemplate.txt";
    
    private const string class_dest_path = "Assets/ScriptableVariables/Scripts/Classes/AutoGenerated/Types/{0}Variable.cs";
    private const string listener_dest_path = "Assets/ScriptableVariables/Scripts/Classes/AutoGenerated/Listeners/{0}StructListener.cs";
    private const string editor_dest_path = "Assets/ScriptableVariables/Scripts/Editor/AutoGenerated/Types/{0}Editor.cs";

    private const string header =
@"
///////////////////////////////////////////////////////////////////
///// Automatically generated by CustomValueTypeGenerator.cs //////
///////////////////////////////////////////////////////////////////
";
    private enum Type
    {
        _bool, _int, _long, _float, _double, 
        _Quaternion, _Vector2, _Vector2Int,
        _Vector3, _Vector3Int, _Vector4, _Vector4Int
    }

    private static string nameStr = "";
    private static int numValues = 0;

    private struct Entry
    {
        public Type type;
        public string name;
        public bool equals;
        public bool show;
    }

    private static Entry[] entries;

    [MenuItem("Window/Scriptable Variables/Create or delete Custom Value Type")]
    public static void CreateNewEnumType()
    {
        CustomValueTypeGenerator window = (CustomValueTypeGenerator)GetWindow(typeof(CustomValueTypeGenerator));
        window.Show();
    }

    private void OnGUI()
    {
        GUILayout.Label("Custom Value Type Generator", EditorStyles.boldLabel);
        GUILayout.Space(40f);
        nameStr = EditorGUILayout.TextField("Type Name: ", nameStr);
        GUILayout.Space(10f);
        int tmp = EditorGUILayout.IntField("Number of Values: ", numValues);

        if (tmp != numValues)
        {
            if (entries == null)
                entries = new Entry[tmp];
            else
            {
                Entry[] tmpEntries = new Entry[tmp];
                for (int i = 0; i < ((tmp < numValues) ? tmp : numValues); ++i)
                {
                    tmpEntries[i] = entries[i];
                }
                entries = tmpEntries;
            }
            numValues = tmp;
        }

        for (int i = 0; i < numValues; ++i)
        {
            string fieldName = (entries[i].name != null && entries[i].name.Length > 0)
                ? entries[i].name
                : $"Field {i}";

            entries[i].show = EditorGUILayout.Foldout(entries[i].show, fieldName);
            if(entries[i].show)
            {
                entries[i].name = EditorGUILayout.TextField("Name: ", entries[i].name ?? "");
                entries[i].type = (Type)EditorGUILayout.EnumPopup("Type: ", entries[i].type);
                entries[i].equals = EditorGUILayout.Toggle("Include in equality check?", entries[i].equals);
            }
        }

        GUILayout.Space(20f);
        if (GUILayout.Button("Generate Scripts"))
        {
            if (!IsNameValid(nameStr))
            {
                EditorUtility.DisplayDialog(
                    $"Invalid Class Name: {nameStr}",
                    "should start with a letter and should only contain letters, numbers and underscores.",
                    "Alrighty then");
                return;
            }

            if (entries == null)
            {
                EditorUtility.DisplayDialog(
                    "Not enough fields",
                    "Custom structs should have at least one field.",
                    "Alrighty then");
                return;
            }

            foreach (Entry e in entries)
            {
                if(!IsNameValid(e.name))
                {
                    EditorUtility.DisplayDialog(
                        $"Invalid Field Name: {e.name}",
                        "should start with a letter and should only contain letters, numbers and underscores.",
                        "Alrighty then");
                    return;
                }
            }
            bool hasEquals = false;
            Array.ForEach(entries, entry => hasEquals |= entry.equals);

            if(!hasEquals)
            {
                EditorUtility.DisplayDialog(
                    $"No fields for equality check",
                    "At least one of your fields should be marked for equality checks.",
                    "Alrighty then");
                return;
            }

            bool fallthrough = false;

            for (int j = 0; j < entries.Length; ++j)
            {
                if (entries[j].name == null || entries[j].name.Length < 1)
                {
                    if (!fallthrough)
                    {
                        int answ = EditorUtility.DisplayDialogComplex(
                            "Incomplete Type?",
                            $"Field {j} is not named.\nIt will receive a default name.",
                            "Go ahead",
                            "Apply to all",
                            "Abort!");

                        if (answ == 2)
                        {
                            return;
                        }

                        if (answ == 1)
                        {
                            fallthrough = true;
                        }
                    }
                    entries[j].name = $"field_{j}";
                }
            }

            if (entries.GroupBy(e => e.name.ToLower()).Select(g => g.First()).Count() != entries.Length)
            {
                EditorUtility.DisplayDialog("Error", "Your Type contains duplicate field names (ignoring case).", "Sad");
                return;
            }

            string fieldDeclarations = "";

            Array.ForEach(entries,
                (Entry e) =>
                    fieldDeclarations += $"public {e.type.ToString().Substring(1)} {e.name};\n\t\t");

            string equalsConditions = "";
            var eqEntries = entries.ToList().OrderByDescending(e => e.equals).ToArray();

            int k = 0;
            for (; k + 1 < eqEntries.Count(); ++k)
            {
                equalsConditions += $"{eqEntries[k].name}.Equals(other.{eqEntries[k].name}) &&\n\t\t\t";
            }
            equalsConditions += $"{eqEntries[k].name}.Equals(other.{eqEntries[k].name});";


            string editorFields = "";

            k = 0;
            for (; k + 1 < entries.Length; ++k)
            {
                editorFields += TypeToEditorField(entries[k].type, entries[k].name) + "\n\t\t";
            }
            editorFields += TypeToEditorField(entries[k].type, entries[k].name);

            try
            {
                string scriptTemplate = File.ReadAllText(class_src_path);
                string listenerTemplate = File.ReadAllText(listener_src_path);
                string editorTemplate = File.ReadAllText(editor_src_path);

                string scriptStr = string.Format(
                    scriptTemplate,
                    nameStr,
                    fieldDeclarations,
                    equalsConditions
                );

                string listenerStr = string.Format(
                    listenerTemplate,
                    nameStr
                );

                string editorStr = string.Format(
                    editorTemplate,
                    nameStr,
                    editorFields
                );

                FileInfo file = new FileInfo(string.Format(class_dest_path, nameStr));
                file.Directory.Create(); // If the directory already exists, this method does nothing.
                File.WriteAllText(file.FullName, scriptStr);

                file = new FileInfo(string.Format(listener_dest_path, nameStr));
                file.Directory.Create();
                File.WriteAllText(file.FullName, listenerStr);

                file = new FileInfo(string.Format(editor_dest_path, nameStr));
                file.Directory.Create();
                File.WriteAllText(file.FullName, editorStr);

                EditorUtility.DisplayDialog(
                    "Success",
                    $"created class script\n\n{string.Format(class_dest_path, nameStr)}\n\n" +
                    $"listener script\n\n{string.Format(listener_dest_path, nameStr)}\n\n" +
                    $"and editor script\n\n{string.Format(editor_dest_path, nameStr)}",
                    "Nicenstein"
                );
                AssetDatabase.Refresh();
            }
            catch (Exception e)
            {
                EditorUtility.DisplayDialog("Error", e.Message, "Sad");
            }
        }

        else if (GUILayout.Button("Find and Delete"))
        {
            try
            {
                FileInfo file = new FileInfo(string.Format(class_dest_path, nameStr));
                file.Delete();

                file = new FileInfo(string.Format(listener_dest_path, nameStr));
                file.Delete();

                file = new FileInfo(string.Format(editor_dest_path, nameStr));
                file.Delete();

                EditorUtility.DisplayDialog(
                    "Success",
                    $"deleted class script\n\n{string.Format(class_dest_path, nameStr)}\n\n" +
                    $"listener script\n\n{string.Format(listener_dest_path, nameStr)}\n\n" +
                    $"and editor script\n\n{string.Format(editor_dest_path, nameStr)}",
                    "They had it coming"
                );

                AssetDatabase.Refresh();
            }
            catch (Exception e)
            {
                EditorUtility.DisplayDialog("Error", e.Message, "Sad");
            }
        }
    }

    private static bool IsNameValid(string name)
    {
        // should start with a letter and can only contain numbers, letters and underscores
        Regex validName = new Regex("^[a-zA-Z]+[0-9a-zA-Z_]*$");
        return validName.IsMatch(name);
    }

    private string TypeToEditorField(Type type, string name)
    {
        string fieldTemplate = (type != Type._Quaternion)
            ? "value.{0} = EditorGUILayout.{1}(\"{0}\", value.{0});"
            : "value.{0} = Quaternion.Euler(EditorGUILayout.{1}(\"{0}\", value.{0}.eulerAngles));";

        string typeStr;

        switch (type)
        {
            case Type._bool:
                typeStr = "Toggle";
                break;
            case Type._Quaternion:
                typeStr = "Vector3Field";
                break;
            default:
                typeStr = type.ToString().ElementAt(1).ToString().ToUpper() + type.ToString().Substring(2) + "Field";
                break;
        }
        return string.Format(fieldTemplate, name, typeStr);
    }
}
// 0: Header
// 1: Name
// 2: Enum Values
// 3: Enum Length
// 4: Bits (16 or 32)
// 5: Default Value
// 6: Backing Type

{0}

using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using InflamedGums.Util.Types;

namespace InflamedGums.Util.ScriptableVariables
{{
    /// <summary>
    /// Variable that represents an array of {1} values.
    /// Internally, it uses {3} arrays of {6}s to represent the states for each bit position.
    /// Can represent {4} states at a time.
    /// </summary>
    [CreateAssetMenu(menuName = "Scriptable Objects/Enum Masks/{1}")]
    public class {1}Mask : ScriptableObject, IEnumerable<{1}Mask.{1}>
    {{
        public enum {1}
        {{
            {2}
        }}

        public {1} defaultValue = {1}._{5};

        public delegate void MaskChangedEvent(BitMask{4} dirty);
        /// <summary>
        /// This event is fired when the BackingField property of this variable is set.
        /// The parameter is a BitMask{4}, showing all positions that have changed.
        /// </summary>
        public event MaskChangedEvent OnMaskChanged;

        public delegate void ValueChangedEvent({1} newValue, int position);
        /// <summary>
        /// Fires when a single value of the mask is changed by using the [] operator.
        /// First parameter: new value. Second parameter: bit position that has changed.
        /// </summary>
        public event ValueChangedEvent OnValueChanged;
        /// <summary>
        /// You can optionally define a function here that checks whether this value can be edited.
        /// </summary>
        public bool isLocked =  false;

        [SerializeField]
        private {6}[] bms = new {6}[{3}];

        /// <summary>
        /// Array like getter/setter.
        /// Use this operator to get/set single enum values in the array.
        /// The setter invokes the OnValueChanged event.
        /// </summary>
        public {1} this[int position]
        {{
            get
            {{
                int outValue = 0;
                BitMask{4} bm;
                for(int i = 0; i < {3}; ++i)
                {{
                    bm = bms[i];
                    outValue += (bm[position]) ? 1 << i : 0;
                }}
                return ({1})outValue;
            }}
            set
            {{
                {1} currentValue = this[position];
                if (currentValue != value && !isLocked)
                {{
                    BitMask{4} from = (BitMask{4})(uint)value;

                    for(int i = 0; i < {3}; ++i)
                    {{
                        BitMask{4} to = bms[i];
                        to[position] = from[i];
                        bms[i] = to;
                    }}

                    BitMask{4} dirty = 0;
                    dirty[position] = true;
                    OnValueChanged?.Invoke(value, position);
                }}
            }}
        }}

        /// <summary>
        /// Grants access to the {6} values that are used
        /// to describe the current state of the mask.
        /// When set, invokes the OnMaskChanged event.
        /// </summary>
        public {6}[] BackingField
        {{
            get 
            {{
                {6}[] copy = new {6}[bms.Length];
                bms.CopyTo(copy, 0);
                return copy;
            }}
            set
            {{
                BitMask{4} dirty = 0;
                for (int i = 0; i < {3}; ++i)
                {{
                    BitMask{4} left = bms[i], right = value[i];
                    dirty = left.XOR(right).OR(dirty);
                }}

                if(dirty > 0 && !isLocked) 
                {{
                    bms = value;
                    OnMaskChanged?.Invoke(dirty);
                }}
            }}
        }}

        /// <summary>
        /// Use to broadcast a change in the mask, even though it hasn't actually changed.
        /// Invokes the OnMaskChanged event.
        /// Still works when the variable is locked, as the actual value doesn't change.
        /// </summary>
        public void SetDirty(BitMask{4} dirtyMask)
            => OnMaskChanged?.Invoke(dirtyMask);
        
        /// <summary>
        /// Returns a mask that is set to true for every position that currently is in the given state.
        /// </summary>
        public BitMask{4} GetAllWithState({1} state)
        {{
            BitMask{4} outBm = 0;
            BitMask{4} stateBm = (BitMask{4})(uint)(state);
            BitMask{4} cmp;

            for (int i = 0; i < {3}; ++i)
            {{
                cmp = 0;
                cmp = (stateBm[i]) ? cmp.Inverse() : cmp;
                outBm = cmp.AND(bms[i]).OR(outBm);
            }}
            return outBm;
        }}

        public IEnumerator<{1}> GetEnumerator()
        {{
            for(int i = 0; i < {4}; ++i)
                yield return this[i];
        }}

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        /// <summary>
        /// Resets all values to {1}._{5}.
        /// Triggers the OnMaskChanged event.
        /// </summary>
        public void Reset() 
        {{
            {6}[] bms_cpy = BackingField;
            BitMask{4} bm = (BitMask{4})(uint)defaultValue;

            for(int i = 0; i < {3}; ++i) 
            {{
                bms_cpy[i] = 0;

                if(bm[i])
                    bms_cpy[i] = ((BitMask{4})bms[i]).Inverse();
            }}
            BackingField = bms_cpy;
        }}
    }}
}}

